# 一、二分查找

用区间（开闭）来理解

## 704. 二分查找

特点：可能含有负值、数组中所有元素不重复

- 思路1：顺序查找
- 思路2：二分法
  - 三个指针（头尾和中间）
- 注意点
  - 数组的区间（左闭右闭、左闭右开）——与头尾指针的定义相关，影响到中间指针
    - 如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right)
      - while (left < right)，这里使用 < ,因为left == right在区间[left, right)是没有意义的
      - if (nums[middle] > target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]
    - **防止溢出的做法**：`middle = left + （right - left）/ 2`
      - 在面试或者实际场景中，你不一定知道输入的数组有多长，万一数组长度达到int最大值，`left + right`可能会发生==加法溢出==

## 相关题目

### 35.搜索插入位置

与704的区别：判断查找失败后目标值与middle指针值的关系

### 34. 在排序数组中查找元素的第一个和最后一个位置

- 非递减：可能有重复值

- 我的思路
  - 先二分法找到值，再左右延伸找边界
    - 限制条件较多，容易犯错

### 69. x 的平方根

- 我的思路：
  - 除以2来减少二分法范围
    - 但是一开始没有注意边界`x=1`
- 这道题==用二分法的依据==：对于非负整数m来说，由于m越小越满足m^2^≤x，m越大越不满足m^2^≤x，**有单调性**，可以二分答案。
- 设定的固定开区间：46341：46341^2^>2^31^-1=2146483647

### 367. 有效的完全平方数

# 二、移除元素

双指针法

## 27. 移除元素

删掉与val值相同的元素

- 我的思路：双指针
  - 按索引来遍历导致边界情况较复杂，花了大量时间来排查
    - 按索引来遍历时代码的边界条件没写好
- 灵茶山艾府
  - 其实也是双指针，但是比较巧妙
    - **遍历数组**时直接==枚举==，而**不是按索引**来遍历
    - `for x in nums:`
    - `for (int x : nums) {}`
  - 虚拟一个数组按顺序将不相等的值放进去（实际直接对原来的数组上赋值）

## 相关题目

### 26.删除排序数组中的重复项

- 我的思路
  - 双指针for循环，AC了但是效率不是最优
- 灵茶
  - 直接比较当前元素与前一个元素
    - 直观地反映了“**排序数组中相邻元素不相等即为新元素**”的逻辑**（非严格递增的情况下）**

### 283.移动零

- 快慢指针——把所有非0元素往前移动

### 844.比较含退格的字符串

- 我的思路
  - 先清理字符串再进行比较
  - 将字符串转化为列表
  - 边界条件较多
    - 字符串长度
    - 索引越界（下界）
    - 最后一个字符为backspace
  - 清理时用了之前的方法
    - 实际上到最后实现了一个栈
  - 效率较低
- 优秀思路（双指针）
  - ==**从数组尾部开始匹配**==
    - 尾部的字符不会被前面的#清除掉，可以在一次遍历中同时进行**删除和比较**
    - 从头开始会导致在遍历一次数组前都无法判断当前字符是否会被删除
- 其它普通思路
  - **栈**——先删，完全处理后再比较

### 977.有序数组的平方

见四

# 三、有序数组的平方

## 977.有序数组的平方

- 初始思路
  - 先遍历一次数组将数变为平方，再调list.sort()库（快排）：O(n + nlogn)
- 双指针
  - 数组平方后特点：从0开始向两边递增
    - 因此可以从两边开始向中间双指针比较
      - 与其从中间开始向两边合并，不如**从两边开始向中间合并**，这样**无需计算从中间的哪个位置开始**。
  - 空间换时间——新的数组来存

- 但是常规双指针方法对每个元素值计算的乘法次数可能不止一次
- 比较`-nums[i]`和`nums[j]`
  - 非严格递增——当`i`到达0左边是，元素值一定比`j`小

# 四、长度最小的子数组

## 209.长度最小的子数组

审题！！！是大于等于！！！

- 滑动窗口

python实现左或右指针时可以用枚举

## 相关题目

### 904. 水果成篮

- python用字典来快速替换哈希表

- 我的思路：滑动窗口
  - 窗口内有3种则缩短窗口，直到只剩两种，然后再进行延伸
  - 不断记录最大长度
  - 利用字典记录窗口内的种类数
    - `fruit_types = defaultdict(int)`
      - key不存在时可以直接fruit_types[fruit_type] += 1
    - 不需要len(a.keys())，直接len(a)就行
    - del a[i]



### 76. 最小覆盖子串

- 我的思路

  - 覆盖了则移动左界，没覆盖则移动右界

  - 哈希表记录目标字符串中每个字符的频数

  - 判断子串中是否已含有所有的字符（及相应的频数）

    - 哈希表中所有的value $\le0$
    - `return all(value <= 0 for value in t_map.values())`

  - ==代码优化==

    - 利用`Counter`计数器

      ```python
      cnt_s = Counter()  # s 子串字母的出现次数
      cnt_t = Counter(t)  # t 中字母的出现次数
      
      cnt_s[c] += 1  # 右端点字母移入子串
      while cnt_s >= cnt_t:  # 涵盖
      ```

- 优化思路
  - 上面的代码每次都要花费 O(∣Σ∣) 的时间去判断是否涵盖，能不能优化到 O(1) 呢？
    - O(∣Σ∣) ：∣Σ∣ 为字符集合的大小，本题字符均为英文字母，所以 ∣Σ∣=52
  - ==。。。待看==

**有优化的思路，记得看**

# 五、螺旋矩阵II

## 59. 螺旋矩阵 II

- 我的思路
  `matrix = [[0] * n for _ in range(n)]`
  - 主要问题在边界的判断上
    - **直接判断下一个位置是否已经有数字（不为0）就行了**
  - 粗心大意
    - 复制代码时没有看清楚对应的flag
      - 条件太多容易看混——写少量注释

- ==代码优化待看==

  - 利用一个**方向数组**来表示方向，可以省去多个判断的flag

    ```python
    DIRS = (0, 1), (1, 0), (0, -1), (-1, 0)  # 右下左上
    ```

    - 每次移动，行号增加`DIRS[idx][0]`，列号增加`DIRS[idx][1]`

  - 利用索引来转向：`(idx+1) % 4`

## 相关题目

### 54.螺旋矩阵

- 耗时分析
  - 主要耗时为：没有看**题设的矩阵元素**值范围

### 剑指Offer 29.顺时针打印矩阵

> [LCR 146. 螺旋遍历二维数组](https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)

与54相同

多了一种``matrix = []`的情况

# 六、区间和（前缀和）

## 58.区间和（第九期模拟笔试）

> ACM输入输出模式
>
> https://kamacoder.com/problempage.php?pid=1070
>

数据读取与输出：

```python
# 读取
import sys
input = sys.stdin.read

def main():
    # split换行符和空格
    data = input.split()
    index = 0
    n = int(data[index])
    index += 1
    vec = []
    for i in range(n):
        vec.append(data[index])
        index += 1
    # 。。。
    while index < len(data):
        a = int(data[index])
        b = int(data[index + 1])
        index += 2
	# 。。。
    # 输出
    for result in results:
        print(result)

```

- 直接暴力解会超时

  - 来举一个极端的例子，如果我查询m次，每次查询的范围都是从0 到 n - 1

    那么该算法的时间复杂度是 O(n * m) ，m 是查询的次数

- 前缀和先算结果，直接查就很快

# 七、开发商购买土地

> ACM输入输出模式
>
> https://kamacoder.com/problempage.php?pid=1044
>

- python取绝对值
  - `abs()`
- 分别存储行和、列和
  - 然后再计算前缀和
    - 不需要存，直接用sum来进行比较
- sum储存总价值，比较的时候直接减掉就行
  - 减法时需要\*2——因为被减数是total

# 八、总结

https://programmercarl.com/数组总结篇.html

- 读取输入时记得要转换数据类型（int）