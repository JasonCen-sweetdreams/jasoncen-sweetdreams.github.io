# 基本概念（搜索树）

- ==还要看一下时间复杂度==

- 回溯三问
  - 当前操作
  - 子问题
  - 下一个子问题

- 用回溯来替代循环嵌套
  - 降低循环嵌套的复杂度
  - 处理不定长的情况时更简单

处理好边界条件和非边界转换，剩下的交给数学归纳法

- ==时间复杂度==：分析回溯问题的时间复杂度，有一个通用公式：**路径长度**×**搜索树的叶子数**。

## 17.电话号码

> 中等

利用**递归**来实现回溯

循环时注意：有的数字对应4个字母

每次循环生成答案时需要花费O(n)的时间（n为传入字符串长度）

时间复杂度（n*4^n）

- 不需要还原全局变量/恢复现场
  - **因为操作是覆盖而不是拼接**

# 一、子集型回溯

> 01背包问题也可算入此类型

**每个元素都可以选/不选**

### 78.子集

> 中等

- 思路1：
- 要点
  - **选/不选**
  - 全局变量的处理
    - 退出递归时还原
      - 运行是串行的，所以可以这样做
    - 记录答案时深拷贝

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        ans = []
        path = []
        n = len(nums)
        def dfs(i):
            if i == n:
                # 深拷贝
                ans.append(path.copy())
                return
            # 不选
            dfs(i+1)
            # 选
            path.append(nums[i])
            dfs(i+1)
            # 还原全局变量
            path.pop()

        dfs(0)
        return ans
```

- 思路2：
  - 必须要选
  - 选数时限制下标的大小关系
  - **与思路1区别：每次递归都记录答案**
    - 树的每个长度都是答案

### 131.分割回文串

> 中等

- key：**规定问题为：是否选当前逗号**——回归成之前的问题的模板
  - 比起决定选不选当前字符，代码更简洁
    - 这种方法也是可行的，需要设一个局部变量记录当前子串，并且在添加后判断是否回文

- 三问
  - 1.选择当前串加入path——隐含意义：**前面已经选好了**
  - 2.从更大的下标中构造回文分割——隐含意义：**选当前的**
  - 3.比2更大的下标中构造回文分割——隐含意义：**当前的选好后，继续选后面的**
- **判断回文串**
  - 法1：**相遇的双指针**
  - 法2：将字符串**反向**，判断相等
    `if t == t[::-1]`

- 时间复杂度
  - 与上一题一样

# 二、组合型回溯

### 77. 组合

> 中等

- **倒序**枚举
  `for j in range(i, 0, -1)`：(0, i]
  - 复杂度要比正序低很多
- 法2：
  - 选或不选
  - **可以不选的条件**：剩余的数量大于剩余所需的数量

### 216.组合综合III

> 中等

- 审题！！！
  - ==只使用数字1到9!!!==
  - 因此**漏剪**的枝
    - 最大当前子串最大的`k-len`个数的和小于剩余所需的和
    - `//`代表返回int结果（`/`会返回float）
- **复杂度分析**
  - https://leetcode.cn/problems/combinations/solutions/1815859/dfs-suan-fa-de-fu-za-du-fen-xi-by-hqztru-14v8/

- 最完美的剪枝

```python
def dfs(i, t):
    # t--remaining sum
    d = k - len(path)
    if t < 0 or t > (i*2 - d + 1) * d // 2:
        return
    #上面已经将所有无法达成题目目标的枝叶剪掉了
    if len(path) == k:
        ans.append(...)
    for j in range(...):
        ... # 不需要在这里做条件判断，进去函数里面再做逻辑会更清晰
```

- 选/不选
  - 不选i+1的条件：后面的不满足：t > (i*2 - d + 1) * d // 2

复杂度：O(*k*⋅*C*(9,*k*))

### 22.括号生成

> 中等

- 注意这里没有根据下标选元素
- 边界：
  - 多余左括号数为0时不能选右括号
  - 剩余字符数
- 可以使用**不恢复现场**的做法——结果中**每个元素是等长**的
  - 直接==覆盖==

# 三、排列型回溯

**不是集合了**——[1,2,3]、[1,3,2]...

- 可用方法
  - 数组path记录路径上已选的数
  - **集合s**记录路径上剩余未选数字

### 46.全排列

> 中等

- 我的判断方法
  `if nums[j] not in path[0:i]`

  - 因为path[0:0]是[]
  - 当前元素之前还未使用该元素

- 利用额外数组的写法

  ```python
  class Solution:
      def permute(self, nums: List[int]) -> List[List[int]]:
          n = len(nums)
          ans = []
          path = [0] * n  # 所有排列的长度都是一样的 n
          on_path = [False] * n
          def dfs(i: int) -> None:
              if i == n:
                  ans.append(path.copy())
                  return
              for j, on in enumerate(on_path):
                  if not on:
                      path[i] = nums[j]  # 从没有选的数字中选一个
                      on_path[j] = True  # 已选上
                      dfs(i + 1)
                      on_path[j] = False  # 恢复现场
                      # 注意 path 无需恢复现场，因为排列长度固定，直接覆盖就行
          dfs(0)
          return ans
  ```

- 利用集合的写法

  ```python
  class Solution:
      def permute(self, nums: List[int]) -> List[List[int]]:
          # 1. 每个位置都要填一个数
          # 2. 每个位置填的数互不相同
          n = len(nums)
          ans = []
          path = [0] * n
          def dfs(i: int, s: Set[int]) -> None:
              if i == n:
                  ans.append(path.copy())
                  return
              for x in s:
                  path[i] = x
                  dfs(i + 1, s - {x})
          dfs(0, set(nums))
          return ans
  ```

==**时间复杂度：O(n*n!)**==

### 51.N 皇后

> 困难

- "."的填充可以用 **当前列号**和**总列数**来实现

- 需要记录的
  - 数组1：每行的Q所放的列值
  - 集合：剩余可用的列值
    - `set(range(n))`
    - 集合运算：`s-{c}`
  - （可选的优化）：用两个布尔数组/哈希表记录两种斜线的值
    - 要注意计算时，**列号是从0开始的**
    - 斜线数量==$n*2-1$

# 附录

## 为什么列表不需要声明为nonlocal而普通变量（如int类型）需要

- 变量 `res` 是一个不可变对象（整型）。在内部函数 `dfs` 中，**我们使用了赋值语句 `res = min(len(path), res)`。这条语句会让 Python 认为 `res` 是在 `dfs` 内部定义的局部变量**，而不会使用外层作用域中的 `res`。为了能修改外层的 `res`，必须用 `nonlocal res` 声明，明确告诉 Python 我们想要修改外层的变量。
- 变量 `path` 是一个列表（可变对象）。在内部函数中，我们**没有对 `path` 进行重新赋值**（比如 `path = [...]`），**而只是调用了它的修改方法（`append` 和 `pop`）**，这些方法是直接修改列表对象本身。因为我们没有重新绑定 `path` 这个变量，所以不需要使用 `nonlocal` 声明。